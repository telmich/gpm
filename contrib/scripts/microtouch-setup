#!/bin/sh
#
# This program is execute by tclsh if we are in the console, and by wish
# otherwise (assuming we are under a graphic environment

#the following is a comment for tcl \
if [ $TERM = "linux" ] ; then exec tclsh $0 $* ; fi

#the following is another comment for tcl \
exec wish $0 $*

########### That's Tcl...

puts "Calibration program for Microtouch screens"

set who [exec whoami]
if [string compare $who root] {
    puts stderr "you must be root to be able to run this program"
}


if ![string compare $env(TERM) linux] {

    # Text-mode calibration

    if {![info exists env(COLUMNS)] || ![info exists env(LINES)]} {
	puts stderr "Please set COLUMNS and LINES in your environment"
	puts stderr " for example, you can issue"
	puts stderr "        eval `resize`"
	puts stderr " in your shell before running this program"
	exit 1
    }
    fconfigure stdout -buffering none
    exec clear > /dev/tty

    proc goto {x y} {
	set x [expr $x]
	set y [expr $y]
	puts -nonewline [format "\x1B\[%03i;%03iH" $y $x]
    }

    # To use "calibrate extended we must draw targets at 1/8 and 7/8 x-y
    set x [expr $env(COLUMNS)/8]
    set y [expr $env(LINES)/8]
    set X [expr $env(COLUMNS) - $x]
    set Y [expr $env(LINES) - $y]

    # half x and y
    set hx [expr $env(COLUMNS)/2]
    set hy [expr $env(LINES)/2]

    goto $hx-10 $hy-1; puts -nonewline "Please touch the lower"
    goto $hx-10 $hy-0; puts -nonewline "left target, then the"
    goto $hx-10 $hy+1; puts -nonewline "upper right target."

    exec killall -STOP gpm
    set F [open /dev/mouse r+]
    fconfigure $F -buffering none
    puts $F "\1CX\r"

    set ack [gets $F]; # Acknowledge
    goto $hx-18 $hy+3; puts -nonewline "received acknowledge: please start"

    goto $x $Y-1; puts -nonewline "|"
    goto $x-1 $Y; puts -nonewline "-+-"
    goto $x $Y+1; puts -nonewline "|"

    set ack [gets $F]; # First calibration point
    goto $hx-5 $hy+4; puts -nonewline "received acknowledge: please go on"

    #remove the target, draw the other
    goto $x $Y-1; puts -nonewline " "
    goto $x-1 $Y; puts -nonewline "   "
    goto $x $Y+1; puts -nonewline " "

    goto $X $y-1; puts -nonewline "|"
    goto $X-1 $y; puts -nonewline "-+-"
    goto $X $y+1; puts -nonewline "|"

    set ack [gets $F]; # Next calibration point
    goto $hx-5 $hy+5; puts -nonewline "received acknowledge: looks ok"

    goto $X $y-1; puts -nonewline " "
    goto $X-1 $y; puts -nonewline "   "
    goto $X $y+1; puts -nonewline " "
    close $F

    exec killall -CONT gpm
    goto 0 $env(LINES)-2

    puts "Done"
    exit 0

}

# X calibration. This is Tk, so we can use the canvas items.
# However, there is uncertainty about the absolute X and Y...

set wid [winfo screenwidth .]
set hei [winfo screenheight .]
wm geometry . ${wid}x${hei}+0+0

set x [expr $wid/8]
set y [expr $hei/8]
set X [expr $wid - $x]
set Y [expr $hei - $y]
set hx [expr $wid/2]
set hy [expr $hei/2]
set cwid [expr 2*$x]
set chei [expr 2*$y]

# The offset variables account for window manager borders etc
set xoff1 0
set yoff1 0
set xoff2 0
set yoff2 0

proc recanvas {} {
    global x y X Y xoff1 xoff2 yoff1 yoff2
    catch {.l.c delete line}
    catch {.r.c delete line}
    
    set x1 [expr $x-$xoff1]
    set y1 [expr $Y-$yoff1]
    set x2 [expr $X-$xoff2]
    set y2 [expr $y-$yoff2]
    
    .l.c create line [expr $x1-50] $y1 [expr $x1+50] $y1 \
	    -width 3 -fill red -tag line
    .l.c create line $x1 [expr $y1-50] $x1 [expr $y1+50] \
	    -width 3 -fill red -tag line
    
    .r.c create line [expr $x2-50] $y2 [expr $x2+50] $y2 \
	    -width 3 -fill red -tag line
    .r.c create line $x2 [expr $y2-50] $x2 [expr $y2+50] \
	    -width 3 -fill red -tag line
}


pack [frame .l] -side left -expand true -fill both 
pack [frame .m] -side left -expand true -fill both 
pack [frame .r] -side left -expand true -fill both 
pack [canvas .l.c -width $cwid -hei $chei -scrollregion "0 0 $cwid $chei" \
	] -side bottom 
pack [frame .l.f] -expand true -fill both; #filler
pack [canvas .r.c -width $cwid -hei $chei -scrollregion "0 0 $cwid $chei" \
	] -side top
pack [frame .r.f] -expand true -fill both; #filler

pack [label .m.t -text "MicroTouch Calibrator" -foreground blue] -pady 40
pack [label .m.l -bd 5 -relief raised] -expand true -fill both
pack [label .m.s] -expand true -fill both

bind .l.c <Enter> {
    set xoff1 [expr %X - %x]
    set yoff1 [expr %Y - %y]
    set x1 [expr $x-$xoff1]
    set y1 [expr $Y-$yoff1]

    catch {.l.c delete line}
    
    .l.c create line [expr $x1-50] $y1 [expr $x1+50] $y1 \
	    -width 3 -fill red -tag line
    .l.c create line $x1 [expr $y1-50] $x1 [expr $y1+50] \
	    -width 3 -fill red -tag line
    
    set done1 1
    update
}
bind .r.c <Enter> {
    set xoff2 [expr %X - %x]
    set yoff2 [expr %Y - %y]
    set x2 [expr $X-$xoff2]
    set y2 [expr $y-$yoff2]

    catch {.r.c delete line}

    .r.c create line [expr $x2-50] $y2 [expr $x2+50] $y2 \
	    -width 3 -fill red -tag line
    .r.c create line $x2 [expr $y2-50] $x2 [expr $y2+50] \
	    -width 3 -fill red -tag line

    set done2 1
    update
}

set done1 0; set done2 0

update

.m.l config -text "Please move the mouse towards\n\
	the lower left corner, until a cross\n\
	appears (there's no need to click)"
vwait done1

update

if !$done2 {
    .m.l config -text "Please move the mouse towards\n\
	    the upper right corner, until a cross\n\
	    appears (there's no need to click)"
    vwait done2
}

.m.l config -text "\nWait....\n"
after 1000

.m.l config -text "Please touch the lower-left taget\n\
	and then the upper-right target\n\
	to calibrate the touch screen"
update

exec killall -STOP gpm
set F [open /dev/mouse r+]
fconfigure $F -buffering none
puts $F "\1CX\r"

set ack [gets $F]; # Acknowledge
.m.s configure -text "Calibration started"
update

set ack [gets $F]; # First calibration point
.l.c itemco line -fill green
.m.s configure -text "First target ok"
update

set ack [gets $F]; # Next calibration point
.r.c itemco line -fill green
.m.s configure -text "Second target ok"
update

close $F

exec killall -CONT gpm
after 1000
.m.s configure -text ""
pack [button .m.b -text Ok -command exit]

exit 0
